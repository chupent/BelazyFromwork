# Redis

**Redis是一个key-value类型的内存数据库，整个数据库加载在内存中操作，定期通过异步操作将数据flush到磁盘进行保存。**

- 10w/s读写操作
- key、value最大限制512M(建议不超过1kb)

**缺点：受物理内存影响，不可用于海量数据高性能读写，因此主要局限小数据量高性能操作和运算。**



#### Redis支持数据类型

- String(字符串)

- List（集合）

- Set（集合）

- Sorted Set（有序集合）

- Hash（哈希）

	

#### 数据淘汰策略

1. no-eviction:禁止驱逐数据
2. allkeys-lru:从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
3. allkeys-random:从数据集（server.db[i].dict）中任意选择数据淘汰
4. volatile-lru:从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
5. volatile-random:从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
6. volatile-ttl:从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

#####  淘汰机制：

- ​	LRU淘汰机制

- ​	TTL淘汰机制



#### 应用场景

1. 会话缓存
2. 全页缓存
3. 队列
4. 排行榜、计数器
5. 发布/订阅









- 缓存设计&原理

- 缓存架构设计思路

- 缓存数据类型

- 访问操作

- 底层结构和原理

- 缓存过期&淘汰策略

- 通信协议

- 事件处理机制

- 持久化机制

- 发布订阅

- 事务机制

- Lua脚本

- 慢查询日志

- 监视器

- 高可用方案

- 主从复制

- 哨兵模式

- 集群分区

- 缓存穿透

	**请求访问缓存、数据库都未查询到数据，由于数据库中没有数据，无法做缓存，导致每次都会进行查询数据库，缓存失效。大流量情况可能导致数据无法处理而崩溃。**

	解决方案

	```
	1、接口校验
	2、缓存空值
	3、布隆过滤器
	```

- 缓存击穿

	**某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库**

	```
	1、热点数据不过期
	2、加互斥锁
	```

- 缓存雪崩

	**大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂**

	```
	1、过期时间打散
	2、热点数据不过期
	3、加互斥锁
	```

- 数据不一致

- 数据迸发竞争

- Hot key

- big key

- 缓存与数据库一致

- 分布式锁





